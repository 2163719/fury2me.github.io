# **来自刚刚入门多智能体系统故障检测算法的小白的分享！**   
# **——基于matlab R2018a**   
## **用到的一些基本函数**   
* unifrnd（）：生成连续均匀的随机数，如```R = unifrnd(-1,1,2,1)```，生成一个2行1列的矩阵R，矩阵元素在-1到1之间随机生成。   
* horzcat（）：水平拼接数组（矩阵），要求数组行数相等。如```Fib = horzcat([0;0;0;0],[1;1;1;1])```,将4行1列的矩阵水平拼接成4行2列的矩阵。   
* int8（）：可将数据转化为8位（1字节）带符号的整数。   
* ones（）：创建矩阵元素全是1的矩阵。如```ones（1,2）```，生成1行2列的矩阵，矩阵元素全是1。  
* zeros（）：创建矩阵元素全是0的矩阵。   
* eye（）：生成单位矩阵。如```eye(4)```生成4×4单位矩阵。
* inv（）：矩阵求逆。
* plot（）：matlab绘图中最常用的函数。如```plot(t,R,t,J,'--')```,表示在figure图中绘出两条曲线，自变量都是t，因变量分别是R和J，其中R默认为实线，J默认为虚线“--”。在基本的图中可以添加横纵轴的标签：```xlabel('t'),ylabel('y')```。还可以添加图例：```legend('R','J')```，分别标明两条曲线所代表的含义。   
综合在一起，给出一个例子
```plot(t,R,t,J,'--'),xlabel('t'),ylabel('y'),legend('R','J')```绘出的图如下所示：      
![figure1](https://github.com/2163719/fury2me.github.io/blob/master/1.png)   

## **连续时间方程离散化处理**   
* c2d（）：将s域的表达式转化成z域的表达式，s=0对应z=1。如```H = tf([1 -1],[1 4 5],'InputDelay', 0.3);c2d(H,0.1,'foh')```，表示用一阶保持器法将H离散化，采样周期为0.1s，foh表示一阶保持器法。如果不写最后一项则默认使用零阶保持器法，此外还有两种方法：tustin，双线性变换法；imp，脉冲响应不变法。

## **求解Riccati离散时间代数方程**   
* [X,L,G] = dare(A,B,Q,R,S,E)：话不多说，直接贴上matlab帮助文档里边提供的解释   
![figure2](https://github.com/2163719/fury2me.github.io/blob/master/2.png)   
* [V,D] = eig(A)：返回特征值的对角矩阵D，并返回矩阵V，矩阵V的列是对应的右特征向量，即```A*V=V*D```

## **LMI求解**  
LMI即线性矩阵不等式，matlab自带LMI工具箱，很强大，我在网上找的一个教程，讲得蛮详细的，就是有点模糊（捂脸）   
[MatlabLMI工具箱中文版介绍及使用教程](https://github.com/2163719/fury2me.github.io/blob/master/MatlabLMI%E5%B7%A5%E5%85%B7%E7%AE%B1%E4%B8%AD%E6%96%87%E7%89%88%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.pdf)

## **递归算法**      
对连续时间方程进行离散化处理后，出现```x(k+1) = x(k)```类似的式子，因此就用到了递归算法，而且```x(k)```还是多维矩阵，给运算增添了难度。一开始运行一直有问题，后来在网上查了递归算法中最经典也是最基础的案例——斐波那契数列，这才有了思路。代码如下，其中k是采样次数，因此```x(k)```要封装成一个自定义的函数，k需要自己赋值。   
```
if k == 0
    x1 = [0;0;0;0];
else
    Op = [0;0;0;0];
    Fibb = horzcat(Op,zeros(4,k));
    for i=1:1:k
        Fibb(:,i+1) = A*Fibb(:,i)+B;%Fibb(:,i+1)代表第i+1列，也就是x(k+1)
    end
end
```
其中A、B代表式子中的各个系数矩阵，具体视算法情况而定。

